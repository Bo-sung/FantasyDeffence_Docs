<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Îã§Ï§ë ÏòÅÏó≠ Î∂ÑÌï† ÏãúÏä§ÌÖú</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 900px;
            margin: 20px auto;
            padding: 20px;
            background: #1a1a1a;
            color: #e0e0e0;
        }
        h1 {
            color: #4CAF50;
            text-align: center;
        }
        .controls {
            background: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        .control-group {
            margin-bottom: 15px;
        }
        label {
            display: inline-block;
            width: 150px;
            color: #b0b0b0;
        }
        input[type="range"] {
            width: 200px;
            vertical-align: middle;
        }
        input[type="number"] {
            width: 60px;
            background: #3a3a3a;
            border: 1px solid #555;
            color: #e0e0e0;
            padding: 5px;
            border-radius: 4px;
        }
        button {
            background: #4CAF50;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            margin: 5px;
        }
        button:hover {
            background: #45a049;
        }
        #canvas {
            border: 2px solid #4CAF50;
            display: block;
            margin: 20px auto;
            background: white;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        .info {
            background: #2a2a2a;
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
        }
        .info h3 {
            color: #4CAF50;
            margin-top: 0;
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 8px;
            margin-top: 10px;
            max-height: 400px;
            overflow-y: auto;
        }
        .stat-item {
            background: #3a3a3a;
            padding: 8px;
            border-radius: 5px;
            font-size: 0.9em;
        }
        .method-toggle {
            text-align: center;
            margin-bottom: 15px;
        }
        .method-toggle button {
            background: #555;
            margin: 0 5px;
        }
        .method-toggle button.active {
            background: #4CAF50;
        }
    </style>
</head>
<body>
    <h1>üó∫Ô∏è Îã§Ï§ë ÏòÅÏó≠ Î∂ÑÌï† ÏãúÏä§ÌÖú</h1>
    
    <div class="controls">
        <div class="method-toggle">
            <button id="methodPoisson" class="active" onclick="setMethod('poisson')">Poisson Disk (Í∑†Îì±)</button>
            <button id="methodRandom" onclick="setMethod('random')">Random (ÎπÑÍ∑†Îì±)</button>
        </div>
        
        <div class="control-group">
            <label>ÏòÅÏó≠ Í∞úÏàò:</label>
            <input type="range" id="seedCount" min="5" max="30" value="15" step="1">
            <input type="number" id="seedCountValue" min="5" max="30" value="15">
        </div>
        <div class="control-group">
            <label>ÏµúÏÜå Í∞ÑÍ≤©:</label>
            <input type="range" id="minDistance" min="2" max="8" value="3.5" step="0.5">
            <input type="number" id="minDistanceValue" min="2" max="8" value="3.5" step="0.5">
        </div>
        <div class="control-group">
            <label>ÎÖ∏Ïù¥Ï¶à Ïä§ÏºÄÏùº:</label>
            <input type="range" id="noiseScale" min="0.01" max="0.2" value="0.08" step="0.01">
            <input type="number" id="noiseScaleValue" min="0.01" max="0.2" value="0.08" step="0.01">
        </div>
        <div class="control-group">
            <label>ÎÖ∏Ïù¥Ï¶à ÏòÅÌñ•ÎèÑ:</label>
            <input type="range" id="noiseInfluence" min="0" max="2" value="1.0" step="0.1">
            <input type="number" id="noiseInfluenceValue" min="0" max="2" value="1.0" step="0.1">
        </div>
        <div style="text-align: center; margin-top: 20px;">
            <button onclick="generateMap()">üîÑ ÏÉàÎ°úÏö¥ Îßµ ÏÉùÏÑ±</button>
            <button onclick="exportData()">üì• Îç∞Ïù¥ÌÑ∞ ÎÇ¥Î≥¥ÎÇ¥Í∏∞</button>
        </div>
    </div>

    <canvas id="canvas" width="600" height="600"></canvas>

    <div class="info">
        <h3>ÏòÅÏó≠ ÌÜµÍ≥Ñ (Ï¥ù <span id="totalRegions">0</span>Í∞ú ÏòÅÏó≠)</h3>
        <div id="stats" class="stats"></div>
    </div>

    <script>
        const GRID_SIZE = 30;
        const CELL_SIZE = 20;
        const CENTER_START = 10;
        const CENTER_END = 20;
        
        let grid = [];
        let regions = [];
        let seedPoints = [];
        let currentMethod = 'poisson';

        // Perlin ÎÖ∏Ïù¥Ï¶à
        class PerlinNoise {
            constructor() {
                this.perm = this.shuffle([...Array(256)].map((_, i) => i));
                this.perm = [...this.perm, ...this.perm];
            }

            shuffle(array) {
                for (let i = array.length - 1; i > 0; i--) {
                    const j = Math.floor(Math.random() * (i + 1));
                    [array[i], array[j]] = [array[j], array[i]];
                }
                return array;
            }

            fade(t) {
                return t * t * t * (t * (t * 6 - 15) + 10);
            }

            lerp(t, a, b) {
                return a + t * (b - a);
            }

            grad(hash, x, y) {
                const h = hash & 3;
                const u = h < 2 ? x : y;
                const v = h < 2 ? y : x;
                return ((h & 1) === 0 ? u : -u) + ((h & 2) === 0 ? v : -v);
            }

            noise(x, y) {
                const X = Math.floor(x) & 255;
                const Y = Math.floor(y) & 255;
                
                x -= Math.floor(x);
                y -= Math.floor(y);
                
                const u = this.fade(x);
                const v = this.fade(y);
                
                const a = this.perm[X] + Y;
                const b = this.perm[X + 1] + Y;
                
                return this.lerp(v,
                    this.lerp(u, this.grad(this.perm[a], x, y),
                        this.grad(this.perm[b], x - 1, y)),
                    this.lerp(u, this.grad(this.perm[a + 1], x, y - 1),
                        this.grad(this.perm[b + 1], x - 1, y - 1))
                );
            }
        }

        let perlin = new PerlinNoise();

        // Poisson Disk Sampling
        function poissonDiskSampling(count, minDist) {
            const points = [];
            const cellSize = minDist / Math.sqrt(2);
            const gridW = Math.ceil(GRID_SIZE / cellSize);
            const gridH = Math.ceil(GRID_SIZE / cellSize);
            const gridMap = Array(gridH).fill(null).map(() => Array(gridW).fill(null));
            const active = [];

            function isInCenter(x, y) {
                return x >= CENTER_START && x < CENTER_END && 
                       y >= CENTER_START && y < CENTER_END;
            }

            function isValidPoint(x, y) {
                if (x < 0 || x >= GRID_SIZE || y < 0 || y >= GRID_SIZE) return false;
                if (isInCenter(x, y)) return false;

                const gx = Math.floor(x / cellSize);
                const gy = Math.floor(y / cellSize);

                for (let dy = -2; dy <= 2; dy++) {
                    for (let dx = -2; dx <= 2; dx++) {
                        const nx = gx + dx;
                        const ny = gy + dy;
                        
                        if (nx >= 0 && nx < gridW && ny >= 0 && ny < gridH && gridMap[ny][nx]) {
                            const other = gridMap[ny][nx];
                            const dist = Math.sqrt((other.x - x) ** 2 + (other.y - y) ** 2);
                            if (dist < minDist) return false;
                        }
                    }
                }

                return true;
            }

            // Ï≤´ Ìè¨Ïù∏Ìä∏
            let firstX, firstY;
            do {
                firstX = Math.random() * GRID_SIZE;
                firstY = Math.random() * GRID_SIZE;
            } while (isInCenter(firstX, firstY));

            const first = { x: firstX, y: firstY };
            points.push(first);
            active.push(first);
            const gx = Math.floor(firstX / cellSize);
            const gy = Math.floor(firstY / cellSize);
            gridMap[gy][gx] = first;

            // ÎÇòÎ®∏ÏßÄ Ìè¨Ïù∏Ìä∏ ÏÉùÏÑ±
            let attempts = 0;
            while (active.length > 0 && points.length < count && attempts < 10000) {
                const idx = Math.floor(Math.random() * active.length);
                const point = active[idx];
                let found = false;

                for (let i = 0; i < 30; i++) {
                    const angle = Math.random() * Math.PI * 2;
                    const radius = minDist + Math.random() * minDist;
                    const newX = point.x + Math.cos(angle) * radius;
                    const newY = point.y + Math.sin(angle) * radius;

                    if (isValidPoint(newX, newY)) {
                        const newPoint = { x: newX, y: newY };
                        points.push(newPoint);
                        active.push(newPoint);
                        const ngx = Math.floor(newX / cellSize);
                        const ngy = Math.floor(newY / cellSize);
                        gridMap[ngy][ngx] = newPoint;
                        found = true;
                        break;
                    }
                }

                if (!found) {
                    active.splice(idx, 1);
                }
                attempts++;
            }

            return points.slice(0, count);
        }

        // ÎûúÎç§ Î∞∞Ïπò
        function randomSampling(count, minDist) {
            const points = [];
            let attempts = 0;

            while (points.length < count && attempts < 5000) {
                const x = Math.random() * GRID_SIZE;
                const y = Math.random() * GRID_SIZE;
                
                if (x >= CENTER_START && x < CENTER_END && 
                    y >= CENTER_START && y < CENTER_END) {
                    attempts++;
                    continue;
                }
                
                const tooClose = points.some(p => 
                    Math.sqrt((p.x - x) ** 2 + (p.y - y) ** 2) < minDist
                );
                
                if (!tooClose) {
                    points.push({ x, y });
                }
                attempts++;
            }

            return points;
        }

        // Î©îÏÑúÎìú Î≥ÄÍ≤Ω
        function setMethod(method) {
            currentMethod = method;
            document.getElementById('methodPoisson').classList.toggle('active', method === 'poisson');
            document.getElementById('methodRandom').classList.toggle('active', method === 'random');
            generateMap();
        }

        // ÌååÎùºÎØ∏ÌÑ∞ ÎèôÍ∏∞Ìôî
        function syncInputs() {
            ['seedCount', 'noiseScale', 'noiseInfluence', 'minDistance'].forEach(id => {
                const slider = document.getElementById(id);
                const input = document.getElementById(id + 'Value');
                
                slider.addEventListener('input', (e) => {
                    input.value = e.target.value;
                });
                
                input.addEventListener('input', (e) => {
                    slider.value = e.target.value;
                });
            });
        }

        // ÏÉâÏÉÅ ÏÉùÏÑ± (Îçî Îã§ÏñëÌïú ÏÉâÏÉÅ)
        function getRegionColor(regionId) {
            if (regionId === 0) return '#FFD700';
            
            // Golden angleÏùÑ ÏÇ¨Ïö©Ìïú ÏÉâÏÉÅ Î∂ÑÏÇ∞
            const hue = (regionId * 137.508) % 360;
            const saturation = 60 + (regionId % 3) * 10;
            const lightness = 50 + (regionId % 4) * 5;
            return `hsl(${hue}, ${saturation}%, ${lightness}%)`;
        }

        // Í±∞Î¶¨ Í≥ÑÏÇ∞
        function calculateDistance(x1, y1, x2, y2, noiseScale, noiseInfluence) {
            const euclidean = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
            const noiseValue = perlin.noise(x1 * noiseScale, y1 * noiseScale);
            const noiseFactor = 1 + noiseValue * noiseInfluence;
            
            return euclidean * noiseFactor;
        }

        // Îßµ ÏÉùÏÑ±
        function generateMap() {
            const seedCount = parseInt(document.getElementById('seedCount').value);
            const minDistance = parseFloat(document.getElementById('minDistance').value);
            const noiseScale = parseFloat(document.getElementById('noiseScale').value);
            const noiseInfluence = parseFloat(document.getElementById('noiseInfluence').value);

            perlin = new PerlinNoise();
            grid = Array(GRID_SIZE).fill(null).map(() => Array(GRID_SIZE).fill(-1));
            seedPoints = [];

            // 1. Ï§ëÏïô ÏòÅÏó≠ ÏÑ§Ï†ï
            for (let y = CENTER_START; y < CENTER_END; y++) {
                for (let x = CENTER_START; x < CENTER_END; x++) {
                    grid[y][x] = 0;
                }
            }

            // 2. ÏãúÎìú Ìè¨Ïù∏Ìä∏ ÏÉùÏÑ±
            const rawPoints = currentMethod === 'poisson' 
                ? poissonDiskSampling(seedCount, minDistance)
                : randomSampling(seedCount, minDistance);

            seedPoints = rawPoints.map((p, i) => ({
                x: Math.floor(p.x),
                y: Math.floor(p.y),
                id: i + 1
            }));

            console.log(`ÏÉùÏÑ±Îêú ÏãúÎìú Ìè¨Ïù∏Ìä∏: ${seedPoints.length}Í∞ú`);

            // 3. ÏòÅÏó≠ Ìï†Îãπ
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    if (grid[y][x] === 0) continue;

                    let minDist = Infinity;
                    let closestSeed = -1;

                    seedPoints.forEach(seed => {
                        const dist = calculateDistance(x, y, seed.x, seed.y, noiseScale, noiseInfluence);
                        if (dist < minDist) {
                            minDist = dist;
                            closestSeed = seed.id;
                        }
                    });

                    grid[y][x] = closestSeed;
                }
            }

            calculateRegionStats();
            render();
        }

        // ÌÜµÍ≥Ñ Í≥ÑÏÇ∞
        function calculateRegionStats() {
            regions = [];
            const regionCounts = {};

            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const id = grid[y][x];
                    regionCounts[id] = (regionCounts[id] || 0) + 1;
                }
            }

            Object.entries(regionCounts).forEach(([id, count]) => {
                regions.push({
                    id: parseInt(id),
                    count: count,
                    percentage: (count / (GRID_SIZE * GRID_SIZE) * 100).toFixed(1)
                });
            });

            regions.sort((a, b) => b.count - a.count);

            document.getElementById('totalRegions').textContent = regions.length;

            const statsDiv = document.getElementById('stats');
            statsDiv.innerHTML = regions.map(region => `
                <div class="stat-item" style="border-left: 4px solid ${getRegionColor(region.id)}">
                    <strong>${region.id === 0 ? 'Ï¥àÍ∏∞' : `#${region.id}`}</strong>
                    ${region.count}Ïπ∏ (${region.percentage}%)
                </div>
            `).join('');
        }

        // Î†åÎçîÎßÅ
        function render() {
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');

            // Î∞∞Í≤Ω
            ctx.fillStyle = '#f0f0f0';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Í∑∏Î¶¨Îìú Í∑∏Î¶¨Í∏∞
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const regionId = grid[y][x];
                    ctx.fillStyle = getRegionColor(regionId);
                    ctx.fillRect(x * CELL_SIZE, y * CELL_SIZE, CELL_SIZE, CELL_SIZE);
                }
            }

            // ÏòÅÏó≠ Í≤ΩÍ≥Ñ Í∞ïÏ°∞
            ctx.lineWidth = 2;
            for (let y = 0; y < GRID_SIZE; y++) {
                for (let x = 0; x < GRID_SIZE; x++) {
                    const current = grid[y][x];
                    
                    if (x < GRID_SIZE - 1 && grid[y][x + 1] !== current) {
                        ctx.strokeStyle = '#333';
                        ctx.beginPath();
                        ctx.moveTo((x + 1) * CELL_SIZE, y * CELL_SIZE);
                        ctx.lineTo((x + 1) * CELL_SIZE, (y + 1) * CELL_SIZE);
                        ctx.stroke();
                    }
                    
                    if (y < GRID_SIZE - 1 && grid[y + 1][x] !== current) {
                        ctx.strokeStyle = '#333';
                        ctx.beginPath();
                        ctx.moveTo(x * CELL_SIZE, (y + 1) * CELL_SIZE);
                        ctx.lineTo((x + 1) * CELL_SIZE, (y + 1) * CELL_SIZE);
                        ctx.stroke();
                    }
                }
            }

            // ÏãúÎìú Ìè¨Ïù∏Ìä∏ ÌëúÏãú
            seedPoints.forEach(seed => {
                ctx.fillStyle = '#000';
                ctx.beginPath();
                ctx.arc(seed.x * CELL_SIZE + CELL_SIZE/2, 
                       seed.y * CELL_SIZE + CELL_SIZE/2, 
                       3, 0, Math.PI * 2);
                ctx.fill();
                
                ctx.strokeStyle = '#fff';
                ctx.lineWidth = 1;
                ctx.stroke();
            });
        }

        // Îç∞Ïù¥ÌÑ∞ ÎÇ¥Î≥¥ÎÇ¥Í∏∞
        function exportData() {
            const data = {
                gridSize: GRID_SIZE,
                grid: grid,
                regions: regions,
                seedPoints: seedPoints,
                parameters: {
                    seedCount: parseInt(document.getElementById('seedCount').value),
                    minDistance: parseFloat(document.getElementById('minDistance').value),
                    noiseScale: parseFloat(document.getElementById('noiseScale').value),
                    noiseInfluence: parseFloat(document.getElementById('noiseInfluence').value),
                    method: currentMethod
                }
            };
            
            const blob = new Blob([JSON.stringify(data, null, 2)], 
                                 { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `region_map_${seedPoints.length}regions.json`;
            a.click();
        }

        // Ï¥àÍ∏∞Ìôî
        syncInputs();
        generateMap();
    </script>
</body>
</html>