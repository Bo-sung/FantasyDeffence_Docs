---
tags: [server]
---

# 서버 아키텍처

[← README로 돌아가기](../README.md)

---

## 개요

Fantasy Tower Defence의 서버 아키텍처 설계 결정사항 및 통신 전략을 정의합니다.

---

## 아키텍처 선택

### Modular Monolith (모듈식 모놀리스)

**선택 이유**:
- ✅ 초기 개발 속도 빠름 (단일 배포, 통합 디버깅)
- ✅ 운영 복잡도 낮음 (인프라 1대, 배포 단순)
- ✅ 트랜잭션 처리 용이 (DB 트랜잭션 직접 사용)
- ✅ 추후 Microservices 전환 가능 (모듈 경계 명확)

**적용 근거**:
- 프로젝트 초기 단계 (Phase 1~2)
- 소규모 팀 (운영 리소스 제한)
- 중소 규모 동접 목표 (1,000~10,000 CCU)
- 명확한 도메인 경계 (Manor, Hero, Battle, Social)

---

## 모듈 구조

### 핵심 모듈

```mermaid
graph TD
    Server["Monolith Server"]

    Auth["Auth Module<br/>인증/세션 관리"]

    Manor["Manor Module<br/>영지 시스템"]
    ManorB["Building Service"]
    ManorP["Production Service"]
    ManorT["Tax Service"]

    Hero["Hero Module<br/>영웅 시스템"]
    HeroR["Recruit Service"]
    HeroU["Upgrade Service"]
    HeroL["Link Service"]
    HeroRep["Repair Service"]

    Battle["Battle Module<br/>전투 시스템"]
    BattleS["Stage Service"]
    BattleC["Combat Service"]

    Inv["Inventory Module<br/>장비/아이템"]
    Social["Social Module<br/>길드/친구"]
    Money["Monetization Module<br/>결제/상점"]

    Server --> Auth
    Server --> Manor
    Server --> Hero
    Server --> Battle
    Server --> Inv
    Server --> Social
    Server --> Money

    Manor --> ManorB
    Manor --> ManorP
    Manor --> ManorT

    Hero --> HeroR
    Hero --> HeroU
    Hero --> HeroL
    Hero --> HeroRep

    Battle --> BattleS
    Battle --> BattleC

    style Server fill:#4169E1,color:#fff
    style Manor fill:#FFD700
    style Hero fill:#FF6347
    style Battle fill:#32CD32
```

### 모듈 간 통신

**원칙**: 직접 메서드 호출 (동일 프로세스)

```csharp
// 예시: Manor Module에서 Inventory Module 호출
public class ManorBuildingService
{
    private readonly InventoryService _inventoryService;

    public void UpgradeBuilding(int userId, int placementId)
    {
        // 비용 차감 (Inventory Module 호출)
        _inventoryService.ConsumeResource(userId, ResourceType.Silver, 1000);

        // 건물 업그레이드 (Manor Module 로직)
        // ...
    }
}
```

**모듈 경계 규칙**:
- ✅ 공개 Service 인터페이스를 통해서만 호출
- ✅ 데이터 직접 접근 금지 (Repository 패턴 사용)
- ✅ 순환 참조 금지 (의존성 방향 일관성 유지)

---

## 통신 프로토콜 전략

### Hybrid 방식 (RESTful 80% + WebSocket 20%)

#### RESTful API (주력)

**사용 케이스** (80%):
- 상태 조회: GET /api/manor/load
- 상태 변경: POST /api/manor/building/place
- 자원 차감: PATCH /api/inventory/resource

**장점**:
- 구현 단순, 디버깅 용이
- 캐싱 가능 (HTTP Cache-Control)
- 표준 HTTP 도구 활용 (Postman, curl)
- 무상태성 (Stateless) → 수평 확장 유리

**예시**:
```http
POST /api/manor/building/place
Content-Type: application/json

{
  "building_id": "farm_001",
  "x": 10,
  "y": 15
}

Response 200 OK
{
  "placement_id": 12345,
  "stored_amount": 0,
  "production_rate": 60
}
```

---

#### WebSocket (보조)

**사용 케이스** (20%):
- 실시간 생산 진행 알림
- 세금 누적 푸시
- 친구 상태 변경 알림
- 길드 채팅 (Phase 2+)

**장점**:
- 서버 → 클라이언트 푸시 가능
- 낮은 레이턴시 (연결 유지)
- 실시간성 보장

**연결 관리**:

```mermaid
graph TD
    Login["클라이언트 로그인"]
    Connect["WebSocket 연결<br/>(ws://server/ws)"]
    Auth["토큰 인증 → 세션 생성"]
    Subscribe["Redis Pub/Sub 구독<br/>(user:user_id)"]
    Event["서버 이벤트 발생 시<br/>Redis Publish"]
    Push["WebSocket으로<br/>클라이언트 푸시"]

    Login --> Connect --> Auth --> Subscribe --> Event --> Push

    style Login fill:#87CEEB
    style Push fill:#98FB98
```

**메시지 포맷**:
```json
{
  "type": "manor.production.update",
  "data": {
    "placement_id": 12345,
    "stored_amount": 250,
    "max_storage": 500
  }
}
```

---

### 프로토콜 선택 기준

| 상황 | 선택 | 이유 |
|------|------|------|
| 영지 진입 (전체 로드) | RESTful | 대량 데이터 조회, 캐싱 가능 |
| 건물 배치/업그레이드 | RESTful | 상태 변경, 트랜잭션 필요 |
| 생산 진행 알림 (1분마다) | WebSocket | 서버 푸시, 실시간성 |
| 세금 누적 알림 | WebSocket | 서버 푸시 |
| 전투 종료 보상 | RESTful | 상태 변경 |
| 친구 온라인 상태 | WebSocket | 실시간 변경 알림 |
| 길드 채팅 (Phase 2+) | WebSocket | 양방향 실시간 통신 |

---

## 데이터 흐름

### RESTful 요청 흐름

```mermaid
graph TD
    Client["Client"]
    Gateway["API Gateway /<br/>Load Balancer"]
    Auth["Auth Middleware"]
    Manor["Manor Module"]
    DB["DB Transaction"]
    Redis["Redis Cache Update"]
    Response["Response"]

    Client -->|"HTTP POST<br/>/api/manor/building/place"| Gateway
    Gateway --> Auth
    Auth -->|"JWT 토큰 검증"| Manor
    Manor -->|"BuildingService.PlaceBuilding()"| DB
    DB -->|"INSERT manor_building_placement<br/>UPDATE manor_user (자원 차감)<br/>COMMIT"| Redis
    Redis -->|"HSET manor:user:user_id<br/>HSET manor:building:placement_id"| Response
    Response -->|"JSON 반환"| Client

    style Client fill:#87CEEB
    style DB fill:#FFD700
    style Redis fill:#FF6347
    style Response fill:#98FB98
```

---

### WebSocket 푸시 흐름

```mermaid
graph TD
    Job["Background Job"]
    RedisUpdate["Redis Update"]
    Publish["Redis Publish"]
    WSServer["WebSocket Server"]
    Client["Client"]
    UI["Client UI Update"]

    Job -->|"1분마다 생산량 계산"| RedisUpdate
    RedisUpdate -->|"manor:production:placement_id"| Publish
    Publish -->|"PUBLISH user:user_id"| WSServer
    WSServer -->|"Redis Subscribe 수신"| Client
    Client -->|"WebSocket 메시지 푸시"| UI
    UI -->|"생산량 표시 갱신"| UI

    style Job fill:#FFD700
    style RedisUpdate fill:#FF6347
    style Client fill:#87CEEB
    style UI fill:#98FB98
```

---

## 확장 전략

### Phase 1 (초기 출시)

**구조**: Monolith 단일 서버
- RESTful + WebSocket 혼용
- DB + Redis 단일 인스턴스
- 목표: 1,000 CCU

**배포**:

```mermaid
graph LR
    Client["Client"]
    Server["Monolith Server"]
    Data["DB + Redis"]

    Client --> Server --> Data

    style Server fill:#4169E1,color:#fff
    style Data fill:#FFD700
```

---

### Phase 2 (성장기)

**구조**: Monolith + 읽기 복제본
- DB Read Replica 추가 (읽기 부하 분산)
- Redis Cluster (캐시 용량 확장)
- 목표: 5,000 CCU

**배포**:

```mermaid
graph TD
    Client["Client"]
    LB["Load Balancer"]
    Server1["Monolith Server 1"]
    Server2["Monolith Server 2"]
    DBMaster["DB Master"]
    DBReplica["DB Read Replica"]
    RedisCluster["Redis Cluster"]

    Client --> LB
    LB --> Server1
    LB --> Server2
    Server1 --> DBMaster
    Server2 --> DBMaster
    DBMaster -.->|"복제"| DBReplica
    Server1 --> RedisCluster
    Server2 --> RedisCluster

    style LB fill:#87CEEB
    style DBMaster fill:#FFD700
    style DBReplica fill:#FFE4B5
    style RedisCluster fill:#FF6347
```

---

### Phase 3 (대규모)

**구조**: Microservices 전환 (선택적)
- Manor, Hero, Battle 모듈 분리
- API Gateway 도입
- 목표: 10,000+ CCU

**배포**:

```mermaid
graph TD
    Client["Client"]
    Gateway["API Gateway"]
    Manor["Manor Service"]
    Hero["Hero Service"]
    Battle["Battle Service"]
    Social["Social Service"]
    DB["DB Master +<br/>Read Replicas"]
    Redis["Redis Cluster"]

    Client --> Gateway
    Gateway --> Manor
    Gateway --> Hero
    Gateway --> Battle
    Gateway --> Social
    Manor --> DB
    Hero --> DB
    Battle --> DB
    Social --> DB
    Manor --> Redis
    Hero --> Redis
    Battle --> Redis
    Social --> Redis

    style Gateway fill:#4169E1,color:#fff
    style Manor fill:#FFD700
    style Hero fill:#FF6347
    style Battle fill:#32CD32
    style Social fill:#9370DB
    style DB fill:#FFE4B5
    style Redis fill:#FFA07A
```

**마이그레이션 조건**:
- 동접 10,000 이상 지속
- 특정 모듈 부하 집중 (예: Battle 모듈 CPU 90%+)
- 독립 배포 필요성 (예: Manor 업데이트 시 Battle 영향 없이)

---

## 성능 목표

| 항목 | 목표 | 측정 방법 |
|------|------|-----------|
| API 응답 시간 (P95) | < 100ms | RESTful 엔드포인트 |
| WebSocket 레이턴시 | < 50ms | 푸시 전송 시간 |
| 동시 접속 (Phase 1) | 1,000 CCU | WebSocket 연결 수 |
| 처리량 (Phase 1) | 500 RPS | RESTful 요청/초 |
| DB 쿼리 시간 (P95) | < 50ms | 쿼리 로그 분석 |
| Redis 응답 시간 (P99) | < 5ms | Redis INFO 통계 |

---

## 보안

### API 인증

- **JWT 토큰**: 로그인 시 발급 (유효기간 24시간)
- **Refresh Token**: 갱신용 (유효기간 30일)
- **Authorization 헤더**: `Bearer {token}`

**예시**:
```http
GET /api/manor/load
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

---

### WebSocket 인증

**연결 시 토큰 전송**:
```json
// 첫 메시지
{
  "type": "auth",
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}

// 응답
{
  "type": "auth.success",
  "user_id": 12345
}
```

**연결 유지**:
- Heartbeat (30초마다 ping/pong)
- 토큰 만료 전 재인증 요청

---

## 모니터링

### 주요 지표

| 지표 | 도구 | 알람 조건 |
|------|------|-----------|
| API 응답 시간 | Prometheus + Grafana | P95 > 200ms |
| WebSocket 연결 수 | 커스텀 메트릭 | > 8,000 (80% 임계) |
| 에러율 | APM (Application Insights) | > 1% |
| CPU 사용률 | 서버 모니터링 | > 80% |
| 메모리 사용률 | 서버 모니터링 | > 85% |
| DB 커넥션 풀 | DB 모니터링 | 여유 < 10% |

---

## 관련 문서

- [데이터 아키텍처](데이터%20아키텍처.md) - DB/Redis 저장소 계층
- [기술 요구사항](기술%20요구사항.md) - 엔진, 성능 목표
- [영지/데이터 명세](영지/데이터%20명세.md) - API 명세 상세
- [개발 로드맵](개발%20로드맵.md) - Phase별 확장 계획
