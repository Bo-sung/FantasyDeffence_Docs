---
tags: [server]
---

# 서버 아키텍처

[← README로 돌아가기](../README.md)

---

## 개요

Fantasy Tower Defence의 서버 아키텍처 설계 결정사항 및 통신 전략을 정의합니다.

---

## 아키텍처 선택

### Modular Monolith (모듈식 모놀리스)

**선택 이유**:
- ✅ 초기 개발 속도 빠름 (단일 배포, 통합 디버깅)
- ✅ 운영 복잡도 낮음 (인프라 1대, 배포 단순)
- ✅ 트랜잭션 처리 용이 (DB 트랜잭션 직접 사용)
- ✅ 추후 Microservices 전환 가능 (모듈 경계 명확)

**적용 근거**:
- 프로젝트 초기 단계 (Phase 1~2)
- 소규모 팀 (운영 리소스 제한)
- 중소 규모 동접 목표 (1,000~10,000 CCU)
- 명확한 도메인 경계 (Manor, Hero, Battle, Social)

---

## 모듈 구조

### 핵심 모듈

```
Monolith Server
├─ Auth Module          # 인증/세션 관리
├─ Manor Module         # 영지 시스템
│  ├─ Building Service
│  ├─ Production Service
│  └─ Tax Service
├─ Hero Module          # 영웅 시스템
│  ├─ Recruit Service
│  ├─ Upgrade Service
│  ├─ Link Service
│  └─ Repair Service
├─ Battle Module        # 전투 시스템
│  ├─ Stage Service
│  └─ Combat Service
├─ Inventory Module     # 장비/아이템
├─ Social Module        # 길드/친구
└─ Monetization Module  # 결제/상점
```

### 모듈 간 통신

**원칙**: 직접 메서드 호출 (동일 프로세스)

```csharp
// 예시: Manor Module에서 Inventory Module 호출
public class ManorBuildingService
{
    private readonly InventoryService _inventoryService;

    public void UpgradeBuilding(int userId, int placementId)
    {
        // 비용 차감 (Inventory Module 호출)
        _inventoryService.ConsumeResource(userId, ResourceType.Silver, 1000);

        // 건물 업그레이드 (Manor Module 로직)
        // ...
    }
}
```

**모듈 경계 규칙**:
- ✅ 공개 Service 인터페이스를 통해서만 호출
- ✅ 데이터 직접 접근 금지 (Repository 패턴 사용)
- ✅ 순환 참조 금지 (의존성 방향 일관성 유지)

---

## 통신 프로토콜 전략

### Hybrid 방식 (RESTful 80% + WebSocket 20%)

#### RESTful API (주력)

**사용 케이스** (80%):
- 상태 조회: GET /api/manor/load
- 상태 변경: POST /api/manor/building/place
- 자원 차감: PATCH /api/inventory/resource

**장점**:
- 구현 단순, 디버깅 용이
- 캐싱 가능 (HTTP Cache-Control)
- 표준 HTTP 도구 활용 (Postman, curl)
- 무상태성 (Stateless) → 수평 확장 유리

**예시**:
```http
POST /api/manor/building/place
Content-Type: application/json

{
  "building_id": "farm_001",
  "x": 10,
  "y": 15
}

Response 200 OK
{
  "placement_id": 12345,
  "stored_amount": 0,
  "production_rate": 60
}
```

---

#### WebSocket (보조)

**사용 케이스** (20%):
- 실시간 생산 진행 알림
- 세금 누적 푸시
- 친구 상태 변경 알림
- 길드 채팅 (Phase 2+)

**장점**:
- 서버 → 클라이언트 푸시 가능
- 낮은 레이턴시 (연결 유지)
- 실시간성 보장

**연결 관리**:
```
클라이언트 로그인
  ↓
WebSocket 연결 (ws://server/ws)
  ↓
토큰 인증 → 세션 생성
  ↓
Redis Pub/Sub 구독 (user:{user_id})
  ↓
서버 이벤트 발생 시 Redis Publish
  ↓
WebSocket으로 클라이언트 푸시
```

**메시지 포맷**:
```json
{
  "type": "manor.production.update",
  "data": {
    "placement_id": 12345,
    "stored_amount": 250,
    "max_storage": 500
  }
}
```

---

### 프로토콜 선택 기준

| 상황 | 선택 | 이유 |
|------|------|------|
| 영지 진입 (전체 로드) | RESTful | 대량 데이터 조회, 캐싱 가능 |
| 건물 배치/업그레이드 | RESTful | 상태 변경, 트랜잭션 필요 |
| 생산 진행 알림 (1분마다) | WebSocket | 서버 푸시, 실시간성 |
| 세금 누적 알림 | WebSocket | 서버 푸시 |
| 전투 종료 보상 | RESTful | 상태 변경 |
| 친구 온라인 상태 | WebSocket | 실시간 변경 알림 |
| 길드 채팅 (Phase 2+) | WebSocket | 양방향 실시간 통신 |

---

## 데이터 흐름

### RESTful 요청 흐름

```
[Client]
   ↓ HTTP POST /api/manor/building/place
[API Gateway / Load Balancer]
   ↓
[Auth Middleware] → JWT 토큰 검증
   ↓
[Manor Module] → BuildingService.PlaceBuilding()
   ↓
[DB Transaction]
   ├─ INSERT manor_building_placement
   ├─ UPDATE manor_user (자원 차감)
   └─ COMMIT
   ↓
[Redis Cache Update]
   ├─ HSET manor:user:{user_id}
   └─ HSET manor:building:{placement_id}
   ↓
[Response] → JSON 반환
```

---

### WebSocket 푸시 흐름

```
[Background Job] → 1분마다 생산량 계산
   ↓
[Redis Update] → manor:production:{placement_id}
   ↓
[Redis Publish] → PUBLISH user:{user_id} "{...}"
   ↓
[WebSocket Server] → Redis Subscribe 수신
   ↓
[Client] ← WebSocket 메시지 푸시
   ↓
[Client UI Update] → 생산량 표시 갱신
```

---

## 확장 전략

### Phase 1 (초기 출시)

**구조**: Monolith 단일 서버
- RESTful + WebSocket 혼용
- DB + Redis 단일 인스턴스
- 목표: 1,000 CCU

**배포**:
```
[Client] → [Monolith Server] → [DB + Redis]
```

---

### Phase 2 (성장기)

**구조**: Monolith + 읽기 복제본
- DB Read Replica 추가 (읽기 부하 분산)
- Redis Cluster (캐시 용량 확장)
- 목표: 5,000 CCU

**배포**:
```
[Client] → [Load Balancer]
              ↓
         [Monolith Server × 2]
              ↓
         [DB Master] ← [DB Read Replica]
              ↓
         [Redis Cluster]
```

---

### Phase 3 (대규모)

**구조**: Microservices 전환 (선택적)
- Manor, Hero, Battle 모듈 분리
- API Gateway 도입
- 목표: 10,000+ CCU

**배포**:
```
[Client] → [API Gateway]
              ├─ [Manor Service]
              ├─ [Hero Service]
              ├─ [Battle Service]
              └─ [Social Service]
                     ↓
              [DB Master + Read Replicas]
              [Redis Cluster]
```

**마이그레이션 조건**:
- 동접 10,000 이상 지속
- 특정 모듈 부하 집중 (예: Battle 모듈 CPU 90%+)
- 독립 배포 필요성 (예: Manor 업데이트 시 Battle 영향 없이)

---

## 성능 목표

| 항목 | 목표 | 측정 방법 |
|------|------|-----------|
| API 응답 시간 (P95) | < 100ms | RESTful 엔드포인트 |
| WebSocket 레이턴시 | < 50ms | 푸시 전송 시간 |
| 동시 접속 (Phase 1) | 1,000 CCU | WebSocket 연결 수 |
| 처리량 (Phase 1) | 500 RPS | RESTful 요청/초 |
| DB 쿼리 시간 (P95) | < 50ms | 쿼리 로그 분석 |
| Redis 응답 시간 (P99) | < 5ms | Redis INFO 통계 |

---

## 보안

### API 인증

- **JWT 토큰**: 로그인 시 발급 (유효기간 24시간)
- **Refresh Token**: 갱신용 (유효기간 30일)
- **Authorization 헤더**: `Bearer {token}`

**예시**:
```http
GET /api/manor/load
Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...
```

---

### WebSocket 인증

**연결 시 토큰 전송**:
```json
// 첫 메시지
{
  "type": "auth",
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
}

// 응답
{
  "type": "auth.success",
  "user_id": 12345
}
```

**연결 유지**:
- Heartbeat (30초마다 ping/pong)
- 토큰 만료 전 재인증 요청

---

## 모니터링

### 주요 지표

| 지표 | 도구 | 알람 조건 |
|------|------|-----------|
| API 응답 시간 | Prometheus + Grafana | P95 > 200ms |
| WebSocket 연결 수 | 커스텀 메트릭 | > 8,000 (80% 임계) |
| 에러율 | APM (Application Insights) | > 1% |
| CPU 사용률 | 서버 모니터링 | > 80% |
| 메모리 사용률 | 서버 모니터링 | > 85% |
| DB 커넥션 풀 | DB 모니터링 | 여유 < 10% |

---

## 관련 문서

- [데이터 아키텍처](데이터%20아키텍처.md) - DB/Redis 저장소 계층
- [기술 요구사항](기술%20요구사항.md) - 엔진, 성능 목표
- [영지/데이터 명세](영지/데이터%20명세.md) - API 명세 상세
- [개발 로드맵](개발%20로드맵.md) - Phase별 확장 계획
